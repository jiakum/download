<!DOCTYPE NoteCase-File>
<!--LastNote:48-->
<HTML>
<HEAD>
<meta content="text/html;charset=UTF-8" http-equiv="Content-Type">
<meta name="generator" content="NoteCase 1.9.8">
<TITLE></TITLE>
</HEAD>
<BODY>
<DL>
<DT>private</DT>
<!--property:date_created=1524187399-->
<!--property:date_modified=1524187399-->
<DD>
<DL>
<DT>account</DT>
<!--property:date_created=1524187408-->
<!--property:date_modified=1526625799-->
<DD>
account and password<DL>
<DT>personal</DT>
<!--property:date_created=1524187544-->
<!--property:date_modified=1524187544-->
<DD>
<DL>
<DT>sina</DT>
<!--property:date_created=1526609423-->
<!--property:date_modified=1526609431-->
<DD>
2008070220080702
</DD>
<DT>工商bank</DT>
<!--property:date_created=1533786886-->
<!--property:date_modified=1533786908-->
<DD>
账号：6217233901000366304
</DD>
</DL>

</DD>
<DT>baichuan</DT>
<!--property:date_created=1524187561-->
<!--property:date_modified=1524187561-->
<!--property:expanded-->
<DD>
<DL>
<DT>log server</DT>
<!--property:date_created=1524187456-->
<!--property:date_modified=1524188161-->
<DD>
<BR>
国内网址：http://112.74.193.157:10086/cms/<BR>
<BR>
   账号：admin<BR>
   密码：su@baichuan-cloud#admin
</DD>
<DT>email</DT>
<!--property:date_created=1524187586-->
<!--property:date_modified=1524187743-->
<DD>
地址：http://exmail.qq.com/login<BR>
账号：majk@sz-bcs.com.cn
</DD>
<DT>file server</DT>
<!--property:date_created=1524188195-->
<!--property:date_modified=1524188240-->
<DD>
\\192.168.2.200\pub
</DD>
<DT>禅道</DT>
<!--property:date_created=1525428109-->
<!--property:date_modified=1533178178-->
<DD>
地址：http://120.24.98.208:10086/index.php?m=user&amp;f=login&amp;referer=Lw==<BR>
<BR>
https://pms.dev.reolink-keen.com/
</DD>
<DT>svn</DT>
<!--property:date_created=1525676065-->
<!--property:date_modified=1525676106-->
<DD>
name:mjk<BR>
passwd:mjk507<BR>
<BR>
svn://192.168.2.12/2018/project/bipc_4g
</DD>
<DT>ssh</DT>
<!--property:date_created=1525685360-->
<!--property:date_modified=1525688072-->
<DD>
ssh: 192.168.2.11<BR>
name:mjk<BR>
<BR>

</DD>
<DT>samba</DT>
<!--property:date_created=1525688066-->
<!--property:date_modified=1525688080-->
<DD>
samba: \\192.168.2.11\mjk<BR>
name:mjk<BR>
orig passwd:mjk507
</DD>
<DT>wifi</DT>
<!--property:date_created=1525937145-->
<!--property:date_modified=1525937155-->
<DD>
Cisco00680<BR>
41647387
</DD>
</DL>

</DD>
</DL>

</DD>
</DL>

</DD>
<DT>tools</DT>
<!--property:date_created=1530761506-->
<!--property:date_modified=1530761506-->
<!--property:expanded-->
<DD>
<DL>
<DT>securecrt</DT>
<!--property:date_created=1530761511-->
<!--property:date_modified=1530761527-->
<DD>
自动记录日志功能：<BR>
<BR>
1.       选择“选项”&#8212;&#8212;“全局选项”，打开全局选项，在常规设置中找到“默认会话”设置项，点击右侧的“编辑默认设置”：<BR>
<BR>
英文版下：选择“Options”&#8212;&#8212;“Global Options”，打开全局选项，在常规设置中找到“default session”设置项，点击右侧的“edit default settings”：<BR>
%H：主机名                   %S：会话名称                  %Y：年（2位数字）             <BR>
<BR>
%M：月（2位数字）      %D：日（2位数字）         %h：小时（2位数字）         <BR>
<BR>
%m：分钟（2位数字）   %s：秒（2位数字）          %t：毫秒（3位数字）<BR>
<BR>
%%：百分比（%）
</DD>
</DL>

</DD>
<DT>linux</DT>
<!--property:date_created=1528096410-->
<!--property:date_modified=1528096410-->
<!--property:expanded-->
<DD>
<DL>
<DT>application</DT>
<!--property:date_created=1524187816-->
<!--property:date_modified=1524187816-->
<!--property:expanded-->
<DD>
<DL>
<DT>git</DT>
<!--property:date_created=1526033446-->
<!--property:date_modified=1528364010-->
<DD>
compilte:<BR>
NO_R_TO_GCC_LINKER=&quot;-Wl,-rpath=/path/lib&quot; CURLDIR=/home/mjk/usr make prefix=/home/mjk/usr all V=1 -j4<BR>
NO_R_TO_GCC_LINKER=&quot;-Wl,-rpath=/path/lib&quot; CURLDIR=/home/mjk/usr make prefix=/home/mjk/usr install<DL>
<DT>repo</DT>
<!--property:date_created=1526033454-->
<!--property:date_modified=1526624367-->
<DD>
作者：Elpie Kay<BR>
链接：https://www.zhihu.com/question/41440585/answer/91102156<BR>
来源：知乎<BR>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<BR>
<BR>
通常repo通过以下两个命令来下载代码：<BR>
repo init -u git://http://xxx.xxx.xxx/platform/manifest -b $branch -m $manifest --reference=$mirror<BR>
repo sync<BR>
repo init<BR>
会在当前目录下创建.repo文件夹，然后将git://http://xxx.xxx.xxx/platform/manifest从中心服务器上clone到.repo里生成manifests和manifests.git。platform/manifest是一个git，用来存放manifest文件。<BR>
它的每个分支里都必须有一个名为default.xml的文件。因为-m $manifest这个参数是可以省略的，省略的话就相当于-m default.xml。<BR>
之后repo sync会去解析-m指定的manifest，根据里面的配置去clone组成整个项目的各个git。<BR>
--reference参数是可选的，后面接的是镜像代码库的路径，一般用不到这个。<BR>
下面举个实际的例子，看下manifest文件是什么样的。<BR>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<BR>
&lt;manifest&gt; <BR>
 &lt;remote fetch=&quot;git://http://xxx.xxx.xxx&quot; name=&quot;origin&quot; review=&quot;http://xxx.xxx.xxx:8080&quot;/&gt;  <BR>
&lt;default remote=&quot;origin&quot; revision=&quot;main_dev&quot;/&gt;  <BR>
&lt;project name=&quot;platform/mediatek/modem/buildscript&quot; path=&quot;buildscript&quot;&gt;    <BR>
	&lt;copyfile dest=&quot;m&quot; src=&quot;m&quot;/&gt;    <BR>
	&lt;copyfile dest=&quot;Make.bat&quot; src=&quot;Make.bat&quot;/&gt;   <BR>
	 &lt;copyfile dest=&quot;make.pl&quot; src=&quot;make.pl&quot;/&gt;    <BR>
	&lt;copyfile dest=&quot;make.sh&quot; src=&quot;make.sh&quot;/&gt;   <BR>
	 &lt;copyfile dest=&quot;M.bat&quot; src=&quot;M.bat&quot;/&gt;   <BR>
	 &lt;copyfile dest=&quot;BuildMMAA.pl&quot; src=&quot;BuildMMAA.pl&quot;/&gt;  <BR>
&lt;/project&gt;  <BR>
&lt;project name=&quot;platform/mediatek/modem/driver&quot; path=&quot;driver&quot;revision=&quot;352b1d8fb184a0169c6a17b5f6a858730fc51966&quot;upstream=&quot;main_release&quot; /&gt;  <BR>
&lt;project name=&quot;platform/mediatek/modem/make&quot; path=&quot;make&quot;revision=&quot;main_release&quot; /&gt; <BR>
 &lt;project name=&quot;platform/mediatek/modem/middleware&quot; path=&quot;middleware&quot;revision=&quot;tag_20160316&quot; /&gt;  <BR>
&lt;project name=&quot;platform/mediatek/modem/modem&quot; path=&quot;modem&quot; /&gt; <BR>
 &lt;project name=&quot;platform/mediatek/modem/mtk_rel&quot; path=&quot;mtk_rel&quot;/&gt;  <BR>
&lt;project name=&quot;platform/mediatek/modem/custom&quot; path=&quot;custom&quot;/&gt; <BR>
 &lt;project name=&quot;platform/mediatek/modem/tools&quot; path=&quot;tools&quot;/&gt;  <BR>
&lt;project name=&quot;platform/mediatek/modem/interface&quot; path=&quot;interface&quot;/&gt;<BR>
  &lt;project name=&quot;platform/mediatek/modem/service&quot; path=&quot;service&quot;/&gt;<BR>
&lt;/manifest&gt;<BR>
先看remote部分，fetch是服务器地址，可以用“..”来代替；name是默认的remote name，就是git push origin里面那个origin；<BR>
review是gerrit地址（这点是我猜的，不确定）。<BR>
然后是default部分，里面定义了默认的remote和revision。<BR>
下面是project部分，这部分定义了整包代码由哪些git组成。<BR>
name是git在服务器上的相对路径，path是把代码下载下来后在本地的相对路径，path是可以省略的，如果省略那么就认为path和name一样，<BR>
revision是指下载下来的代码要checkout到哪个revision上，这里的revision可以是commit id、branch name、tag name，反正本质上都是commit id。<BR>
利用branch name的特性，revision写branch name的话，那总可以下载到并且checkout出该branch上最新的代码，default.xml中通常用branch name做revision。<BR>
而commit id和tag name就是固定的某个commit了。如果revision用commit id的话，那后面必须跟上upstream，upstream的值是个branch name。revision部分如果省略的话，就等于使用default部分定义的revision。<BR>
project还有个group属性，但我没实际用过，就不展开了<BR>
。还有copyfile部分，这是用来处理一些无法或者不方便直接归类到某个git中去的文件的，譬如项目代码根目录下的几个零散文件，这几个文件所在目录做成一个git的话，等于把整包代码做成了一个git。<BR>
虽然git是可以嵌套的，但这样不方便。repo的做法是将这些文件先放到某个已知git中去，本例就是先放到project buildscript里面去。<BR>
当然，放到某个git里去的动作是由你来做的。然后下载完后再将它们copy到应该在的地方，本例就是根目录下。<BR>
dest是相对于根目录的路径，src是相对于project path的路径。这样一个manifest就可以定义一个完整的项目代码了。<BR>
里面的值大致用于以下命令：<BR>
git clone $fetch/$name -b $upstream -- $path<BR>
git checkout $revision<BR>
cp $path/$src $dest<BR>
通过自由组合project和revision，就可以做出各种搭配的项目代码了。<BR>
常用的几个repo 命令：<BR>
repo sync -j 6 -m $manifestsync时可以重新指定一个manifest，如果这个manifest在.repo/manifests里面，那么只要填它相对于.repo/manifests的路径，否则要填它的全路径。<BR>
repo manifest -r -o $name根据当前代码生成一份manifest，这通常用于记录当前所有git的快照，这样以后或者别人、编译服务器可以根据这个manifest下载到那份代码。<BR>
repo forall -p -c '$command'在每个project下执行一次command，-p会打印出当前在哪个project下，-p可选的。command的内容根据需求来写。<BR>
repo有个常用的环境变量$REPO_PROJECT，值是当前project的name。<BR>
譬如可以用repo forall -p -c 'git remote add server1 git://http://xxx.xxx.xxx/$REPO_PROJECT'来给每个git添加一个remote server1。<BR>
更新: @Shrekergoogle repo本来是用于管理android系统源码的，这份源码不同的版本一般都由450个左右的git组成。<BR>
现在将问题简化一下，假如有一份代码，<BR>
目录结构如下:<BR>
myApp/--<BR>
Hello/--<BR>
--hello.java--<BR>
--Make.mk--<BR>
--ProjectConfig.mk<BR>
--World/--<BR>
--world.java<BR>
--Nihao/--<BR>
--nihao.java<BR>
--Make.mk<BR>
--ProjectConfig.mk<BR>
将这份代码拆分成三个git，Hello, World和Nihao。<BR>
现在要用repo将它们组织起来，组成一份完整的代码myApp。<BR>
这3个git都有两个branch，master和release。<BR>
下面是给master用的default.xml。<BR>
服务器上还有一个git叫platform/manifest，对应的也建了2个branch，分别存放master和release相关的manifest。<BR>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<BR>
&lt;manifest&gt;  <BR>
&lt;remote fetch=&quot;git://http://xxx.xxx.xxx&quot; name=&quot;origin&quot; review=&quot;http://xxx.xxx.xxx:8080&quot;/&gt;  <BR>
&lt;default remote=&quot;origin&quot; revision=&quot;master&quot;/&gt;<BR>
 &lt;project name=&quot;platform/Hello&quot; path=&quot;Hello&quot;&gt;    <BR>
	&lt;copyfile dest=&quot;Make.mk&quot; src=&quot;Make.mk&quot;/&gt;    <BR>
	&lt;copyfile dest=&quot;ProjectConfig.mk&quot; src=&quot;ProjectConfig.mk&quot;/&gt; <BR>
 &lt;/project&gt;  <BR>
&lt;project name=&quot;platform/World&quot; path=&quot;World&quot;/&gt;<BR>
&lt;project name=&quot;platform/Nihao&quot; path=&quot;Nihao&quot;/&gt;<BR>
&lt;/manifest&gt;<BR>
这份manifest描述了以下信息：<BR>
这份代码由3个git（里面的3个project）组成；<BR>
Hello/底下的2个mk文件在repo sync后会被拷贝到代码根目录下；<BR>
这3个git用的都是default revision中描述的分支master。
</DD>
</DL>

</DD>
<DT>gcc</DT>
<!--property:date_created=1526636599-->
<!--property:date_modified=1526636599-->
<DD>
<DL>
<DT>attribute</DT>
<!--property:date_created=1526636602-->
<!--property:date_modified=1526636813-->
<DD>
__attribute__((packed))<BR>
<BR>
1. __attribute__ ((packed)) 的作用就是告诉编译器取消结构在编译过程中的优化对齐,按照实际占用字节数进行对齐，是GCC特有的语法。<BR>
<BR>
example:<BR>
struct node {<BR>
        char name;<BR>
        short len;<BR>
} __attribute__((packed));<BR>
sizeof(struct node) = 3;<BR>
----------------------------------------------------------------------------------------------------------------------------------<BR>
<BR>

</DD>
<DT>-include</DT>
<!--property:date_created=1526954379-->
<!--property:date_modified=1526954569-->
<DD>
-include file<BR>
           Process file as if &quot;#include &quot;file&quot;&quot; appeared as the first line of the primary source file.  However, the first directory searched for file is the preprocessor's working<BR>
           directory instead of the directory containing the main source file.  If not found there, it is searched for in the remainder of the &quot;#include &quot;...&quot;&quot; search chain as normal.<BR>
<BR>
           If multiple -include options are given, the files are included in the order they appear on the command line.<BR>
-include 选项
</DD>
<DT>asm</DT>
<!--property:date_created=1533529176-->
<!--property:date_modified=1533529194-->
<DD>
<BR>
<BR>
static void reverse_buffer(unsigned int *src, int size, unsigned int *dest)<BR>
{<BR>
    unsigned int temp, result;<BR>
    int i;<BR>
<BR>
    for(i = 0;i &lt; size;i++) {<BR>
        temp = src[i];<BR>
<BR>
        asm(&quot;RBIT %0,%1\n\t&quot;<BR>
            &quot;REV  %0,%0&quot;<BR>
                : &quot;=r&quot;(result) : &quot;r&quot;(temp));<BR>
<BR>
        dest[i] = result;<BR>
    }<BR>
}<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
Next: Constraints, Previous: Basic Asm, Up: Using Assembly Language with C   [Contents][Index]<BR>
<BR>
6.45.2 Extended Asm - Assembler Instructions with C Expression Operands<BR>
With extended asm you can read and write C variables from assembler and perform jumps from assembler code to C labels. Extended asm syntax uses colons (‘:’) to delimit the operand parameters after the assembler template:<BR>
<BR>
asm [volatile] ( AssemblerTemplate <BR>
                 : OutputOperands <BR>
                 [ : InputOperands<BR>
                 [ : Clobbers ] ])<BR>
<BR>
asm [volatile] goto ( AssemblerTemplate <BR>
                      : <BR>
                      : InputOperands<BR>
                      : Clobbers<BR>
                      : GotoLabels)<BR>
The asm keyword is a GNU extension. When writing code that can be compiled with -ansi and the various -std options, use __asm__ instead of asm (see Alternate Keywords).<BR>
<BR>
Qualifiers<BR>
volatile<BR>
The typical use of extended asm statements is to manipulate input values to produce output values. However, your asm statements may also produce side effects. If so, you may need to use the volatile qualifier to disable certain optimizations. See Volatile.<BR>
<BR>
goto<BR>
This qualifier informs the compiler that the asm statement may perform a jump to one of the labels listed in the GotoLabels. See GotoLabels.<BR>
<BR>
Parameters<BR>
AssemblerTemplate<BR>
This is a literal string that is the template for the assembler code. It is a combination of fixed text and tokens that refer to the input, output, and goto parameters. See AssemblerTemplate.<BR>
<BR>
OutputOperands<BR>
A comma-separated list of the C variables modified by the instructions in the AssemblerTemplate. An empty list is permitted. See OutputOperands.<BR>
<BR>
InputOperands<BR>
A comma-separated list of C expressions read by the instructions in the AssemblerTemplate. An empty list is permitted. See InputOperands.<BR>
<BR>
Clobbers<BR>
A comma-separated list of registers or other values changed by the AssemblerTemplate, beyond those listed as outputs. An empty list is permitted. See Clobbers and Scratch Registers.<BR>
<BR>
GotoLabels<BR>
When you are using the goto form of asm, this section contains the list of all C labels to which the code in the AssemblerTemplate may jump. See GotoLabels.<BR>
<BR>
asm statements may not perform jumps into other asm statements, only to the listed GotoLabels. GCC’s optimizers do not know about other jumps; therefore they cannot take account of them when deciding how to optimize.<BR>
<BR>
The total number of input + output + goto operands is limited to 30.<BR>
<BR>
Remarks<BR>
The asm statement allows you to include assembly instructions directly within C code. This may help you to maximize performance in time-sensitive code or to access assembly instructions that are not readily available to C programs.<BR>
<BR>
Note that extended asm statements must be inside a function. Only basic asm may be outside functions (see Basic Asm). Functions declared with the naked attribute also require basic asm (see Function Attributes).<BR>
<BR>
While the uses of asm are many and varied, it may help to think of an asm statement as a series of low-level instructions that convert input parameters to output parameters. So a simple (if not particularly useful) example for i386 using asm might look like this:<BR>
<BR>
int src = 1;<BR>
int dst;   <BR>
<BR>
asm (&quot;mov %1, %0\n\t&quot;<BR>
    &quot;add $1, %0&quot;<BR>
    : &quot;=r&quot; (dst) <BR>
    : &quot;r&quot; (src));<BR>
<BR>
printf(&quot;%d\n&quot;, dst);<BR>
This code copies src to dst and add 1 to dst.<BR>
<BR>
6.45.2.1 Volatile<BR>
GCC’s optimizers sometimes discard asm statements if they determine there is no need for the output variables. Also, the optimizers may move code out of loops if they believe that the code will always return the same result (i.e. none of its input values change between calls). Using the volatile qualifier disables these optimizations. asm statements that have no output operands, including asm goto statements, are implicitly volatile.<BR>
<BR>
This i386 code demonstrates a case that does not use (or require) the volatile qualifier. If it is performing assertion checking, this code uses asm to perform the validation. Otherwise, dwRes is unreferenced by any code. As a result, the optimizers can discard the asm statement, which in turn removes the need for the entire DoCheck routine. By omitting the volatile qualifier when it isn’t needed you allow the optimizers to produce the most efficient code possible.<BR>
<BR>
void DoCheck(uint32_t dwSomeValue)<BR>
{<BR>
   uint32_t dwRes;<BR>
<BR>
   // Assumes dwSomeValue is not zero.<BR>
   asm (&quot;bsfl %1,%0&quot;<BR>
     : &quot;=r&quot; (dwRes)<BR>
     : &quot;r&quot; (dwSomeValue)<BR>
     : &quot;cc&quot;);<BR>
<BR>
   assert(dwRes &gt; 3);<BR>
}<BR>
The next example shows a case where the optimizers can recognize that the input (dwSomeValue) never changes during the execution of the function and can therefore move the asm outside the loop to produce more efficient code. Again, using volatile disables this type of optimization.<BR>
<BR>
void do_print(uint32_t dwSomeValue)<BR>
{<BR>
   uint32_t dwRes;<BR>
<BR>
   for (uint32_t x=0; x &lt; 5; x++)<BR>
   {<BR>
      // Assumes dwSomeValue is not zero.<BR>
      asm (&quot;bsfl %1,%0&quot;<BR>
        : &quot;=r&quot; (dwRes)<BR>
        : &quot;r&quot; (dwSomeValue)<BR>
        : &quot;cc&quot;);<BR>
<BR>
      printf(&quot;%u: %u %u\n&quot;, x, dwSomeValue, dwRes);<BR>
   }<BR>
}<BR>
The following example demonstrates a case where you need to use the volatile qualifier. It uses the x86 rdtsc instruction, which reads the computer’s time-stamp counter. Without the volatile qualifier, the optimizers might assume that the asm block will always return the same value and therefore optimize away the second call.<BR>
<BR>
uint64_t msr;<BR>
<BR>
asm volatile ( &quot;rdtsc\n\t&quot;    // Returns the time in EDX:EAX.<BR>
        &quot;shl $32, %%rdx\n\t&quot;  // Shift the upper bits left.<BR>
        &quot;or %%rdx, %0&quot;        // 'Or' in the lower bits.<BR>
        : &quot;=a&quot; (msr)<BR>
        : <BR>
        : &quot;rdx&quot;);<BR>
<BR>
printf(&quot;msr: %llx\n&quot;, msr);<BR>
<BR>
// Do other work...<BR>
<BR>
// Reprint the timestamp<BR>
asm volatile ( &quot;rdtsc\n\t&quot;    // Returns the time in EDX:EAX.<BR>
        &quot;shl $32, %%rdx\n\t&quot;  // Shift the upper bits left.<BR>
        &quot;or %%rdx, %0&quot;        // 'Or' in the lower bits.<BR>
        : &quot;=a&quot; (msr)<BR>
        : <BR>
        : &quot;rdx&quot;);<BR>
<BR>
printf(&quot;msr: %llx\n&quot;, msr);<BR>
GCC’s optimizers do not treat this code like the non-volatile code in the earlier examples. They do not move it out of loops or omit it on the assumption that the result from a previous call is still valid.<BR>
<BR>
Note that the compiler can move even volatile asm instructions relative to other code, including across jump instructions. For example, on many targets there is a system register that controls the rounding mode of floating-point operations. Setting it with a volatile asm, as in the following PowerPC example, does not work reliably.<BR>
<BR>
asm volatile(&quot;mtfsf 255, %0&quot; : : &quot;f&quot; (fpenv));<BR>
sum = x + y;<BR>
The compiler may move the addition back before the volatile asm. To make it work as expected, add an artificial dependency to the asm by referencing a variable in the subsequent code, for example:<BR>
<BR>
asm volatile (&quot;mtfsf 255,%1&quot; : &quot;=X&quot; (sum) : &quot;f&quot; (fpenv));<BR>
sum = x + y;<BR>
Under certain circumstances, GCC may duplicate (or remove duplicates of) your assembly code when optimizing. This can lead to unexpected duplicate symbol errors during compilation if your asm code defines symbols or labels. Using ‘%=’ (see AssemblerTemplate) may help resolve this problem.<BR>
<BR>
6.45.2.2 Assembler Template<BR>
An assembler template is a literal string containing assembler instructions. The compiler replaces tokens in the template that refer to inputs, outputs, and goto labels, and then outputs the resulting string to the assembler. The string can contain any instructions recognized by the assembler, including directives. GCC does not parse the assembler instructions themselves and does not know what they mean or even whether they are valid assembler input. However, it does count the statements (see Size of an asm).<BR>
<BR>
You may place multiple assembler instructions together in a single asm string, separated by the characters normally used in assembly code for the system. A combination that works in most places is a newline to break the line, plus a tab character to move to the instruction field (written as ‘\n\t’). Some assemblers allow semicolons as a line separator. However, note that some assembler dialects use semicolons to start a comment.<BR>
<BR>
Do not expect a sequence of asm statements to remain perfectly consecutive after compilation, even when you are using the volatile qualifier. If certain instructions need to remain consecutive in the output, put them in a single multi-instruction asm statement.<BR>
<BR>
Accessing data from C programs without using input/output operands (such as by using global symbols directly from the assembler template) may not work as expected. Similarly, calling functions directly from an assembler template requires a detailed understanding of the target assembler and ABI.<BR>
<BR>
Since GCC does not parse the assembler template, it has no visibility of any symbols it references. This may result in GCC discarding those symbols as unreferenced unless they are also listed as input, output, or goto operands.<BR>
<BR>
Special format strings<BR>
In addition to the tokens described by the input, output, and goto operands, these tokens have special meanings in the assembler template:<BR>
<BR>
‘%%’<BR>
Outputs a single ‘%’ into the assembler code.<BR>
<BR>
‘%=’<BR>
Outputs a number that is unique to each instance of the asm statement in the entire compilation. This option is useful when creating local labels and referring to them multiple times in a single template that generates multiple assembler instructions.<BR>
<BR>
‘%{’<BR>
‘%|’<BR>
‘%}’<BR>
Outputs ‘{’, ‘|’, and ‘}’ characters (respectively) into the assembler code. When unescaped, these characters have special meaning to indicate multiple assembler dialects, as described below.<BR>
<BR>
Multiple assembler dialects in asm templates<BR>
On targets such as x86, GCC supports multiple assembler dialects. The -masm option controls which dialect GCC uses as its default for inline assembler. The target-specific documentation for the -masm option contains the list of supported dialects, as well as the default dialect if the option is not specified. This information may be important to understand, since assembler code that works correctly when compiled using one dialect will likely fail if compiled using another. See x86 Options.<BR>
<BR>
If your code needs to support multiple assembler dialects (for example, if you are writing public headers that need to support a variety of compilation options), use constructs of this form:<BR>
<BR>
{ dialect0 | dialect1 | dialect2... }<BR>
This construct outputs dialect0 when using dialect #0 to compile the code, dialect1 for dialect #1, etc. If there are fewer alternatives within the braces than the number of dialects the compiler supports, the construct outputs nothing.<BR>
<BR>
For example, if an x86 compiler supports two dialects (‘att’, ‘intel’), an assembler template such as this:<BR>
<BR>
&quot;bt{l %[Offset],%[Base] | %[Base],%[Offset]}; jc %l2&quot;<BR>
is equivalent to one of<BR>
<BR>
&quot;btl %[Offset],%[Base] ; jc %l2&quot;   /* att dialect */<BR>
&quot;bt %[Base],%[Offset]; jc %l2&quot;     /* intel dialect */<BR>
Using that same compiler, this code:<BR>
<BR>
&quot;xchg{l}\t{%%}ebx, %1&quot;<BR>
corresponds to either<BR>
<BR>
&quot;xchgl\t%%ebx, %1&quot;                 /* att dialect */<BR>
&quot;xchg\tebx, %1&quot;                    /* intel dialect */<BR>
There is no support for nesting dialect alternatives.<BR>
<BR>
6.45.2.3 Output Operands<BR>
An asm statement has zero or more output operands indicating the names of C variables modified by the assembler code.<BR>
<BR>
In this i386 example, old (referred to in the template string as %0) and *Base (as %1) are outputs and Offset (%2) is an input:<BR>
<BR>
bool old;<BR>
<BR>
__asm__ (&quot;btsl %2,%1\n\t&quot; // Turn on zero-based bit #Offset in Base.<BR>
         &quot;sbb %0,%0&quot;      // Use the CF to calculate old.<BR>
   : &quot;=r&quot; (old), &quot;+rm&quot; (*Base)<BR>
   : &quot;Ir&quot; (Offset)<BR>
   : &quot;cc&quot;);<BR>
<BR>
return old;<BR>
Operands are separated by commas. Each operand has this format:<BR>
<BR>
[ [asmSymbolicName] ] constraint (cvariablename)<BR>
asmSymbolicName<BR>
Specifies a symbolic name for the operand. Reference the name in the assembler template by enclosing it in square brackets (i.e. ‘%[Value]’). The scope of the name is the asm statement that contains the definition. Any valid C variable name is acceptable, including names already defined in the surrounding code. No two operands within the same asm statement can use the same symbolic name.<BR>
<BR>
When not using an asmSymbolicName, use the (zero-based) position of the operand in the list of operands in the assembler template. For example if there are three output operands, use ‘%0’ in the template to refer to the first, ‘%1’ for the second, and ‘%2’ for the third.<BR>
<BR>
constraint<BR>
A string constant specifying constraints on the placement of the operand; See Constraints, for details.<BR>
<BR>
Output constraints must begin with either ‘=’ (a variable overwriting an existing value) or ‘+’ (when reading and writing). When using ‘=’, do not assume the location contains the existing value on entry to the asm, except when the operand is tied to an input; see Input Operands.<BR>
<BR>
After the prefix, there must be one or more additional constraints (see Constraints) that describe where the value resides. Common constraints include ‘r’ for register and ‘m’ for memory. When you list more than one possible location (for example, &quot;=rm&quot;), the compiler chooses the most efficient one based on the current context. If you list as many alternates as the asm statement allows, you permit the optimizers to produce the best possible code. If you must use a specific register, but your Machine Constraints do not provide sufficient control to select the specific register you want, local register variables may provide a solution (see Local Register Variables).<BR>
<BR>
cvariablename<BR>
Specifies a C lvalue expression to hold the output, typically a variable name. The enclosing parentheses are a required part of the syntax.<BR>
<BR>
When the compiler selects the registers to use to represent the output operands, it does not use any of the clobbered registers (see Clobbers and Scratch Registers).<BR>
<BR>
Output operand expressions must be lvalues. The compiler cannot check whether the operands have data types that are reasonable for the instruction being executed. For output expressions that are not directly addressable (for example a bit-field), the constraint must allow a register. In that case, GCC uses the register as the output of the asm, and then stores that register into the output.<BR>
<BR>
Operands using the ‘+’ constraint modifier count as two operands (that is, both as input and output) towards the total maximum of 30 operands per asm statement.<BR>
<BR>
Use the ‘&amp;’ constraint modifier (see Modifiers) on all output operands that must not overlap an input. Otherwise, GCC may allocate the output operand in the same register as an unrelated input operand, on the assumption that the assembler code consumes its inputs before producing outputs. This assumption may be false if the assembler code actually consists of more than one instruction.<BR>
<BR>
The same problem can occur if one output parameter (a) allows a register constraint and another output parameter (b) allows a memory constraint. The code generated by GCC to access the memory address in b can contain registers which might be shared by a, and GCC considers those registers to be inputs to the asm. As above, GCC assumes that such input registers are consumed before any outputs are written. This assumption may result in incorrect behavior if the asm writes to a before using b. Combining the ‘&amp;’ modifier with the register constraint on a ensures that modifying a does not affect the address referenced by b. Otherwise, the location of b is undefined if a is modified before using b.<BR>
<BR>
asm supports operand modifiers on operands (for example ‘%k2’ instead of simply ‘%2’). Typically these qualifiers are hardware dependent. The list of supported modifiers for x86 is found at x86 Operand modifiers.<BR>
<BR>
If the C code that follows the asm makes no use of any of the output operands, use volatile for the asm statement to prevent the optimizers from discarding the asm statement as unneeded (see Volatile).<BR>
<BR>
This code makes no use of the optional asmSymbolicName. Therefore it references the first output operand as %0 (were there a second, it would be %1, etc). The number of the first input operand is one greater than that of the last output operand. In this i386 example, that makes Mask referenced as %1:<BR>
<BR>
uint32_t Mask = 1234;<BR>
uint32_t Index;<BR>
<BR>
  asm (&quot;bsfl %1, %0&quot;<BR>
     : &quot;=r&quot; (Index)<BR>
     : &quot;r&quot; (Mask)<BR>
     : &quot;cc&quot;);<BR>
That code overwrites the variable Index (‘=’), placing the value in a register (‘r’). Using the generic ‘r’ constraint instead of a constraint for a specific register allows the compiler to pick the register to use, which can result in more efficient code. This may not be possible if an assembler instruction requires a specific register.<BR>
<BR>
The following i386 example uses the asmSymbolicName syntax. It produces the same result as the code above, but some may consider it more readable or more maintainable since reordering index numbers is not necessary when adding or removing operands. The names aIndex and aMask are only used in this example to emphasize which names get used where. It is acceptable to reuse the names Index and Mask.<BR>
<BR>
uint32_t Mask = 1234;<BR>
uint32_t Index;<BR>
<BR>
  asm (&quot;bsfl %[aMask], %[aIndex]&quot;<BR>
     : [aIndex] &quot;=r&quot; (Index)<BR>
     : [aMask] &quot;r&quot; (Mask)<BR>
     : &quot;cc&quot;);<BR>
Here are some more examples of output operands.<BR>
<BR>
uint32_t c = 1;<BR>
uint32_t d;<BR>
uint32_t *e = &amp;c;<BR>
<BR>
asm (&quot;mov %[e], %[d]&quot;<BR>
   : [d] &quot;=rm&quot; (d)<BR>
   : [e] &quot;rm&quot; (*e));<BR>
Here, d may either be in a register or in memory. Since the compiler might already have the current value of the uint32_t location pointed to by e in a register, you can enable it to choose the best location for d by specifying both constraints.<BR>
<BR>
6.45.2.4 Flag Output Operands<BR>
Some targets have a special register that holds the “flags” for the result of an operation or comparison. Normally, the contents of that register are either unmodifed by the asm, or the asm is considered to clobber the contents.<BR>
<BR>
On some targets, a special form of output operand exists by which conditions in the flags register may be outputs of the asm. The set of conditions supported are target specific, but the general rule is that the output variable must be a scalar integer, and the value is boolean. When supported, the target defines the preprocessor symbol __GCC_ASM_FLAG_OUTPUTS__.<BR>
<BR>
Because of the special nature of the flag output operands, the constraint may not include alternatives.<BR>
<BR>
Most often, the target has only one flags register, and thus is an implied operand of many instructions. In this case, the operand should not be referenced within the assembler template via %0 etc, as there’s no corresponding text in the assembly language.<BR>
<BR>
x86 family<BR>
The flag output constraints for the x86 family are of the form ‘=@cccond’ where cond is one of the standard conditions defined in the ISA manual for jcc or setcc.<BR>
<BR>
a<BR>
“above” or unsigned greater than<BR>
<BR>
ae<BR>
“above or equal” or unsigned greater than or equal<BR>
<BR>
b<BR>
“below” or unsigned less than<BR>
<BR>
be<BR>
“below or equal” or unsigned less than or equal<BR>
<BR>
c<BR>
carry flag set<BR>
<BR>
e<BR>
z<BR>
“equal” or zero flag set<BR>
<BR>
g<BR>
signed greater than<BR>
<BR>
ge<BR>
signed greater than or equal<BR>
<BR>
l<BR>
signed less than<BR>
<BR>
le<BR>
signed less than or equal<BR>
<BR>
o<BR>
overflow flag set<BR>
<BR>
p<BR>
parity flag set<BR>
<BR>
s<BR>
sign flag set<BR>
<BR>
na<BR>
nae<BR>
nb<BR>
nbe<BR>
nc<BR>
ne<BR>
ng<BR>
nge<BR>
nl<BR>
nle<BR>
no<BR>
np<BR>
ns<BR>
nz<BR>
“not” flag, or inverted versions of those above<BR>
<BR>
6.45.2.5 Input Operands<BR>
Input operands make values from C variables and expressions available to the assembly code.<BR>
<BR>
Operands are separated by commas. Each operand has this format:<BR>
<BR>
[ [asmSymbolicName] ] constraint (cexpression)<BR>
asmSymbolicName<BR>
Specifies a symbolic name for the operand. Reference the name in the assembler template by enclosing it in square brackets (i.e. ‘%[Value]’). The scope of the name is the asm statement that contains the definition. Any valid C variable name is acceptable, including names already defined in the surrounding code. No two operands within the same asm statement can use the same symbolic name.<BR>
<BR>
When not using an asmSymbolicName, use the (zero-based) position of the operand in the list of operands in the assembler template. For example if there are two output operands and three inputs, use ‘%2’ in the template to refer to the first input operand, ‘%3’ for the second, and ‘%4’ for the third.<BR>
<BR>
constraint<BR>
A string constant specifying constraints on the placement of the operand; See Constraints, for details.<BR>
<BR>
Input constraint strings may not begin with either ‘=’ or ‘+’. When you list more than one possible location (for example, ‘&quot;irm&quot;’), the compiler chooses the most efficient one based on the current context. If you must use a specific register, but your Machine Constraints do not provide sufficient control to select the specific register you want, local register variables may provide a solution (see Local Register Variables).<BR>
<BR>
Input constraints can also be digits (for example, &quot;0&quot;). This indicates that the specified input must be in the same place as the output constraint at the (zero-based) index in the output constraint list. When using asmSymbolicName syntax for the output operands, you may use these names (enclosed in brackets ‘[]’) instead of digits.<BR>
<BR>
cexpression<BR>
This is the C variable or expression being passed to the asm statement as input. The enclosing parentheses are a required part of the syntax.<BR>
<BR>
When the compiler selects the registers to use to represent the input operands, it does not use any of the clobbered registers (see Clobbers and Scratch Registers).<BR>
<BR>
If there are no output operands but there are input operands, place two consecutive colons where the output operands would go:<BR>
<BR>
__asm__ (&quot;some instructions&quot;<BR>
   : /* No outputs. */<BR>
   : &quot;r&quot; (Offset / 8));<BR>
Warning: Do not modify the contents of input-only operands (except for inputs tied to outputs). The compiler assumes that on exit from the asm statement these operands contain the same values as they had before executing the statement. It is not possible to use clobbers to inform the compiler that the values in these inputs are changing. One common work-around is to tie the changing input variable to an output variable that never gets used. Note, however, that if the code that follows the asm statement makes no use of any of the output operands, the GCC optimizers may discard the asm statement as unneeded (see Volatile).<BR>
<BR>
asm supports operand modifiers on operands (for example ‘%k2’ instead of simply ‘%2’). Typically these qualifiers are hardware dependent. The list of supported modifiers for x86 is found at x86 Operand modifiers.<BR>
<BR>
In this example using the fictitious combine instruction, the constraint &quot;0&quot; for input operand 1 says that it must occupy the same location as output operand 0. Only input operands may use numbers in constraints, and they must each refer to an output operand. Only a number (or the symbolic assembler name) in the constraint can guarantee that one operand is in the same place as another. The mere fact that foo is the value of both operands is not enough to guarantee that they are in the same place in the generated assembler code.<BR>
<BR>
asm (&quot;combine %2, %0&quot; <BR>
   : &quot;=r&quot; (foo) <BR>
   : &quot;0&quot; (foo), &quot;g&quot; (bar));<BR>
Here is an example using symbolic names.<BR>
<BR>
asm (&quot;cmoveq %1, %2, %[result]&quot; <BR>
   : [result] &quot;=r&quot;(result) <BR>
   : &quot;r&quot; (test), &quot;r&quot; (new), &quot;[result]&quot; (old));<BR>
6.45.2.6 Clobbers and Scratch Registers<BR>
While the compiler is aware of changes to entries listed in the output operands, the inline asm code may modify more than just the outputs. For example, calculations may require additional registers, or the processor may overwrite a register as a side effect of a particular assembler instruction. In order to inform the compiler of these changes, list them in the clobber list. Clobber list items are either register names or the special clobbers (listed below). Each clobber list item is a string constant enclosed in double quotes and separated by commas.<BR>
<BR>
Clobber descriptions may not in any way overlap with an input or output operand. For example, you may not have an operand describing a register class with one member when listing that register in the clobber list. Variables declared to live in specific registers (see Explicit Register Variables) and used as asm input or output operands must have no part mentioned in the clobber description. In particular, there is no way to specify that input operands get modified without also specifying them as output operands.<BR>
<BR>
When the compiler selects which registers to use to represent input and output operands, it does not use any of the clobbered registers. As a result, clobbered registers are available for any use in the assembler code.<BR>
<BR>
Here is a realistic example for the VAX showing the use of clobbered registers:<BR>
<BR>
asm volatile (&quot;movc3 %0, %1, %2&quot;<BR>
                   : /* No outputs. */<BR>
                   : &quot;g&quot; (from), &quot;g&quot; (to), &quot;g&quot; (count)<BR>
                   : &quot;r0&quot;, &quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;, &quot;r4&quot;, &quot;r5&quot;, &quot;memory&quot;);<BR>
Also, there are two special clobber arguments:<BR>
<BR>
&quot;cc&quot;<BR>
The &quot;cc&quot; clobber indicates that the assembler code modifies the flags register. On some machines, GCC represents the condition codes as a specific hardware register; &quot;cc&quot; serves to name this register. On other machines, condition code handling is different, and specifying &quot;cc&quot; has no effect. But it is valid no matter what the target.<BR>
<BR>
&quot;memory&quot;<BR>
The &quot;memory&quot; clobber tells the compiler that the assembly code performs memory reads or writes to items other than those listed in the input and output operands (for example, accessing the memory pointed to by one of the input parameters). To ensure memory contains correct values, GCC may need to flush specific register values to memory before executing the asm. Further, the compiler does not assume that any values read from memory before an asm remain unchanged after that asm; it reloads them as needed. Using the &quot;memory&quot; clobber effectively forms a read/write memory barrier for the compiler.<BR>
<BR>
Note that this clobber does not prevent the processor from doing speculative reads past the asm statement. To prevent that, you need processor-specific fence instructions.<BR>
<BR>
Flushing registers to memory has performance implications and may be an issue for time-sensitive code. You can provide better information to GCC to avoid this, as shown in the following examples. At a minimum, aliasing rules allow GCC to know what memory doesn’t need to be flushed.<BR>
<BR>
Here is a fictitious sum of squares instruction, that takes two pointers to floating point values in memory and produces a floating point register output. Notice that x, and y both appear twice in the asm parameters, once to specify memory accessed, and once to specify a base register used by the asm. You won’t normally be wasting a register by doing this as GCC can use the same register for both purposes. However, it would be foolish to use both %1 and %3 for x in this asm and expect them to be the same. In fact, %3 may well not be a register. It might be a symbolic memory reference to the object pointed to by x.<BR>
<BR>
asm (&quot;sumsq %0, %1, %2&quot;<BR>
     : &quot;+f&quot; (result)<BR>
     : &quot;r&quot; (x), &quot;r&quot; (y), &quot;m&quot; (*x), &quot;m&quot; (*y));<BR>
Here is a fictitious *z++ = *x++ * *y++ instruction. Notice that the x, y and z pointer registers must be specified as input/output because the asm modifies them.<BR>
<BR>
asm (&quot;vecmul %0, %1, %2&quot;<BR>
     : &quot;+r&quot; (z), &quot;+r&quot; (x), &quot;+r&quot; (y), &quot;=m&quot; (*z)<BR>
     : &quot;m&quot; (*x), &quot;m&quot; (*y));<BR>
An x86 example where the string memory argument is of unknown length.<BR>
<BR>
asm(&quot;repne scasb&quot;<BR>
    : &quot;=c&quot; (count), &quot;+D&quot; (p)<BR>
    : &quot;m&quot; (*(const char (*)[]) p), &quot;0&quot; (-1), &quot;a&quot; (0));<BR>
If you know the above will only be reading a ten byte array then you could instead use a memory input like: &quot;m&quot; (*(const char (*)[10]) p).<BR>
<BR>
Here is an example of a PowerPC vector scale implemented in assembly, complete with vector and condition code clobbers, and some initialized offset registers that are unchanged by the asm.<BR>
<BR>
void<BR>
dscal (size_t n, double *x, double alpha)<BR>
{<BR>
  asm (&quot;/* lots of asm here */&quot;<BR>
       : &quot;+m&quot; (*(double (*)[n]) x), &quot;+&amp;r&quot; (n), &quot;+b&quot; (x)<BR>
       : &quot;d&quot; (alpha), &quot;b&quot; (32), &quot;b&quot; (48), &quot;b&quot; (64),<BR>
         &quot;b&quot; (80), &quot;b&quot; (96), &quot;b&quot; (112)<BR>
       : &quot;cr0&quot;,<BR>
         &quot;vs32&quot;,&quot;vs33&quot;,&quot;vs34&quot;,&quot;vs35&quot;,&quot;vs36&quot;,&quot;vs37&quot;,&quot;vs38&quot;,&quot;vs39&quot;,<BR>
         &quot;vs40&quot;,&quot;vs41&quot;,&quot;vs42&quot;,&quot;vs43&quot;,&quot;vs44&quot;,&quot;vs45&quot;,&quot;vs46&quot;,&quot;vs47&quot;);<BR>
}<BR>
Rather than allocating fixed registers via clobbers to provide scratch registers for an asm statement, an alternative is to define a variable and make it an early-clobber output as with a2 and a3 in the example below. This gives the compiler register allocator more freedom. You can also define a variable and make it an output tied to an input as with a0 and a1, tied respectively to ap and lda. Of course, with tied outputs your asm can’t use the input value after modifying the output register since they are one and the same register. What’s more, if you omit the early-clobber on the output, it is possible that GCC might allocate the same register to another of the inputs if GCC could prove they had the same value on entry to the asm. This is why a1 has an early-clobber. Its tied input, lda might conceivably be known to have the value 16 and without an early-clobber share the same register as %11. On the other hand, ap can’t be the same as any of the other inputs, so an early-clobber on a0 is not needed. It is also not desirable in this case. An early-clobber on a0 would cause GCC to allocate a separate register for the &quot;m&quot; (*(const double (*)[]) ap) input. Note that tying an input to an output is the way to set up an initialized temporary register modified by an asm statement. An input not tied to an output is assumed by GCC to be unchanged, for example &quot;b&quot; (16) below sets up %11 to 16, and GCC might use that register in following code if the value 16 happened to be needed. You can even use a normal asm output for a scratch if all inputs that might share the same register are consumed before the scratch is used. The VSX registers clobbered by the asm statement could have used this technique except for GCC’s limit on the number of asm parameters.<BR>
<BR>
static void<BR>
dgemv_kernel_4x4 (long n, const double *ap, long lda,<BR>
                  const double *x, double *y, double alpha)<BR>
{<BR>
  double *a0;<BR>
  double *a1;<BR>
  double *a2;<BR>
  double *a3;<BR>
<BR>
  __asm__<BR>
    (<BR>
     /* lots of asm here */<BR>
     &quot;#n=%1 ap=%8=%12 lda=%13 x=%7=%10 y=%0=%2 alpha=%9 o16=%11\n&quot;<BR>
     &quot;#a0=%3 a1=%4 a2=%5 a3=%6&quot;<BR>
     :<BR>
       &quot;+m&quot; (*(double (*)[n]) y),<BR>
       &quot;+&amp;r&quot; (n),	// 1<BR>
       &quot;+b&quot; (y),	// 2<BR>
       &quot;=b&quot; (a0),	// 3<BR>
       &quot;=&amp;b&quot; (a1),	// 4<BR>
       &quot;=&amp;b&quot; (a2),	// 5<BR>
       &quot;=&amp;b&quot; (a3)	// 6<BR>
     :<BR>
       &quot;m&quot; (*(const double (*)[n]) x),<BR>
       &quot;m&quot; (*(const double (*)[]) ap),<BR>
       &quot;d&quot; (alpha),	// 9<BR>
       &quot;r&quot; (x),		// 10<BR>
       &quot;b&quot; (16),	// 11<BR>
       &quot;3&quot; (ap),	// 12<BR>
       &quot;4&quot; (lda)	// 13<BR>
     :<BR>
       &quot;cr0&quot;,<BR>
       &quot;vs32&quot;,&quot;vs33&quot;,&quot;vs34&quot;,&quot;vs35&quot;,&quot;vs36&quot;,&quot;vs37&quot;,<BR>
       &quot;vs40&quot;,&quot;vs41&quot;,&quot;vs42&quot;,&quot;vs43&quot;,&quot;vs44&quot;,&quot;vs45&quot;,&quot;vs46&quot;,&quot;vs47&quot;<BR>
     );<BR>
}<BR>
6.45.2.7 Goto Labels<BR>
asm goto allows assembly code to jump to one or more C labels. The GotoLabels section in an asm goto statement contains a comma-separated list of all C labels to which the assembler code may jump. GCC assumes that asm execution falls through to the next statement (if this is not the case, consider using the __builtin_unreachable intrinsic after the asm statement). Optimization of asm goto may be improved by using the hot and cold label attributes (see Label Attributes).<BR>
<BR>
An asm goto statement cannot have outputs. This is due to an internal restriction of the compiler: control transfer instructions cannot have outputs. If the assembler code does modify anything, use the &quot;memory&quot; clobber to force the optimizers to flush all register values to memory and reload them if necessary after the asm statement.<BR>
<BR>
Also note that an asm goto statement is always implicitly considered volatile.<BR>
<BR>
To reference a label in the assembler template, prefix it with ‘%l’ (lowercase ‘L’) followed by its (zero-based) position in GotoLabels plus the number of input operands. For example, if the asm has three inputs and references two labels, refer to the first label as ‘%l3’ and the second as ‘%l4’).<BR>
<BR>
Alternately, you can reference labels using the actual C label name enclosed in brackets. For example, to reference a label named carry, you can use ‘%l[carry]’. The label must still be listed in the GotoLabels section when using this approach.<BR>
<BR>
Here is an example of asm goto for i386:<BR>
<BR>
asm goto (<BR>
    &quot;btl %1, %0\n\t&quot;<BR>
    &quot;jc %l2&quot;<BR>
    : /* No outputs. */<BR>
    : &quot;r&quot; (p1), &quot;r&quot; (p2) <BR>
    : &quot;cc&quot; <BR>
    : carry);<BR>
<BR>
return 0;<BR>
<BR>
carry:<BR>
return 1;<BR>
The following example shows an asm goto that uses a memory clobber.<BR>
<BR>
int frob(int x)<BR>
{<BR>
  int y;<BR>
  asm goto (&quot;frob %%r5, %1; jc %l[error]; mov (%2), %%r5&quot;<BR>
            : /* No outputs. */<BR>
            : &quot;r&quot;(x), &quot;r&quot;(&amp;y)<BR>
            : &quot;r5&quot;, &quot;memory&quot; <BR>
            : error);<BR>
  return y;<BR>
error:<BR>
  return -1;<BR>
}<BR>
6.45.2.8 x86 Operand Modifiers<BR>
References to input, output, and goto operands in the assembler template of extended asm statements can use modifiers to affect the way the operands are formatted in the code output to the assembler. For example, the following code uses the ‘h’ and ‘b’ modifiers for x86:<BR>
<BR>
uint16_t  num;<BR>
asm volatile (&quot;xchg %h0, %b0&quot; : &quot;+a&quot; (num) );<BR>
These modifiers generate this assembler code:<BR>
<BR>
xchg %ah, %al<BR>
The rest of this discussion uses the following code for illustrative purposes.<BR>
<BR>
int main()<BR>
{<BR>
   int iInt = 1;<BR>
<BR>
top:<BR>
<BR>
   asm volatile goto (&quot;some assembler instructions here&quot;<BR>
   : /* No outputs. */<BR>
   : &quot;q&quot; (iInt), &quot;X&quot; (sizeof(unsigned char) + 1), &quot;i&quot; (42)<BR>
   : /* No clobbers. */<BR>
   : top);<BR>
}<BR>
With no modifiers, this is what the output from the operands would be for the ‘att’ and ‘intel’ dialects of assembler:<BR>
<BR>
Operand	‘att’	‘intel’<BR>
%0	%eax	eax<BR>
%1	$2	2<BR>
%3	$.L3	OFFSET FLAT:.L3<BR>
The table below shows the list of supported modifiers and their effects.<BR>
<BR>
Modifier	Description	Operand	‘att’	‘intel’<BR>
a	Print an absolute memory reference.	%A0	*%rax	rax<BR>
b	Print the QImode name of the register.	%b0	%al	al<BR>
c	Require a constant operand and print the constant expression with no punctuation.	%c1	2	2<BR>
E	Print the address in Double Integer (DImode) mode (8 bytes) when the target is 64-bit. Otherwise mode is unspecified (VOIDmode).	%E1	%(rax)	[rax]<BR>
h	Print the QImode name for a “high” register.	%h0	%ah	ah<BR>
H	Add 8 bytes to an offsettable memory reference. Useful when accessing the high 8 bytes of SSE values. For a memref in (%rax), it generates	%H0	8(%rax)	8[rax]<BR>
k	Print the SImode name of the register.	%k0	%eax	eax<BR>
l	Print the label name with no punctuation.	%l3	.L3	.L3<BR>
p	Print raw symbol name (without syntax-specific prefixes).	%p2	42	42<BR>
P	If used for a function, print the PLT suffix and generate PIC code. For example, emit foo@PLT instead of ’foo’ for the function foo(). If used for a constant, drop all syntax-specific prefixes and issue the bare constant. See p above.<BR>
q	Print the DImode name of the register.	%q0	%rax	rax<BR>
w	Print the HImode name of the register.	%w0	%ax	ax<BR>
z	Print the opcode suffix for the size of the current integer operand (one of b/w/l/q).	%z0	l	<BR>
V is a special modifier which prints the name of the full integer register without %.<BR>
<BR>
6.45.2.9 x86 Floating-Point asm Operands<BR>
On x86 targets, there are several rules on the usage of stack-like registers in the operands of an asm. These rules apply only to the operands that are stack-like registers:<BR>
<BR>
Given a set of input registers that die in an asm, it is necessary to know which are implicitly popped by the asm, and which must be explicitly popped by GCC.<BR>
An input register that is implicitly popped by the asm must be explicitly clobbered, unless it is constrained to match an output operand.<BR>
<BR>
For any input register that is implicitly popped by an asm, it is necessary to know how to adjust the stack to compensate for the pop. If any non-popped input is closer to the top of the reg-stack than the implicitly popped register, it would not be possible to know what the stack looked like&#8212;it’s not clear how the rest of the stack “slides up”.<BR>
All implicitly popped input registers must be closer to the top of the reg-stack than any input that is not implicitly popped.<BR>
<BR>
It is possible that if an input dies in an asm, the compiler might use the input register for an output reload. Consider this example:<BR>
<BR>
asm (&quot;foo&quot; : &quot;=t&quot; (a) : &quot;f&quot; (b));<BR>
This code says that input b is not popped by the asm, and that the asm pushes a result onto the reg-stack, i.e., the stack is one deeper after the asm than it was before. But, it is possible that reload may think that it can use the same register for both the input and the output.<BR>
<BR>
To prevent this from happening, if any input operand uses the ‘f’ constraint, all output register constraints must use the ‘&amp;’ early-clobber modifier.<BR>
<BR>
The example above is correctly written as:<BR>
<BR>
asm (&quot;foo&quot; : &quot;=&amp;t&quot; (a) : &quot;f&quot; (b));<BR>
Some operands need to be in particular places on the stack. All output operands fall in this category&#8212;GCC has no other way to know which registers the outputs appear in unless you indicate this in the constraints.<BR>
Output operands must specifically indicate which register an output appears in after an asm. ‘=f’ is not allowed: the operand constraints must select a class with a single register.<BR>
<BR>
Output operands may not be “inserted” between existing stack registers. Since no 387 opcode uses a read/write operand, all output operands are dead before the asm, and are pushed by the asm. It makes no sense to push anywhere but the top of the reg-stack.<BR>
Output operands must start at the top of the reg-stack: output operands may not “skip” a register.<BR>
<BR>
Some asm statements may need extra stack space for internal calculations. This can be guaranteed by clobbering stack registers unrelated to the inputs and outputs.<BR>
This asm takes one input, which is internally popped, and produces two outputs.<BR>
<BR>
asm (&quot;fsincos&quot; : &quot;=t&quot; (cos), &quot;=u&quot; (sin) : &quot;0&quot; (inp));<BR>
This asm takes two inputs, which are popped by the fyl2xp1 opcode, and replaces them with one output. The st(1) clobber is necessary for the compiler to know that fyl2xp1 pops both inputs.<BR>
<BR>
asm (&quot;fyl2xp1&quot; : &quot;=t&quot; (result) : &quot;0&quot; (x), &quot;u&quot; (y) : &quot;st(1)&quot;);<BR>
Next: Constraints, Previous: Basic Asm, Up: Using Assembly Language with C   [Contents][Index]
</DD>
</DL>

</DD>
</DL>

</DD>
<DT>perl</DT>
<!--property:date_created=1528425075-->
<!--property:date_modified=1528425113-->
<DD>
PERL5LIB用于设置perl搜索模块的路径，如：<BR>
export PERL5LIB=$PERL5LIB:/home/mjk/usr/lib/x86_64-linux-gnu/perl/5.22.1
</DD>
<DT>Makefile</DT>
<!--property:date_created=1530589302-->
<!--property:date_modified=1530691682-->
<DD>
    names := a b c d  <BR>
    files := $(foreach n,$(names),$(n).o)<BR>
<BR>
上面的例子中，$(name)中的单词会被挨个取出，并存到变量“n”中，“$(n).o”每次根据“$(n)”计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以，$(files)的值是“a.o b.o c.o d.o”。<BR>
<BR>
注意，foreach中的&lt;var&gt;;参数是一个临时的局部变量，foreach函数执行完后，参数&lt;var&gt;;的变量将不在作用，其作用域只在foreach函数当中。<BR>
<BR>
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------<BR>
在Makefile规则中，通配符会被自动展开。但在变量的定义和函数引用时，通配符将失效。这种情况下如果需要通配符有效，就需要使用函数“wildcard”，<BR>
它的用法是：$(wildcard PATTERN...) 。在Makefile中，它被展开为已经存在的、使用空格分开的、匹配此模式的所有文件列表。<BR>
如果不存在任何符合此模式的文件，函数会忽略模式字符并返回空。需要注意的是：这种情况下规则中通配符的展开和上一小节匹配通配符的区别。<BR>
<BR>
一般我们可以使用“$(wildcard *.c)”来获取工作目录下的所有的.c文件列表。复杂一些用法；可以使用“$(patsubst %.c,%.o,$(wildcard *.c))”，<BR>
首先使用“wildcard”函数获取工作目录下的.c文件列表；之后将列表中所有文件名的后缀.c替换为.o。这样我们就可以得到在当前目录可生成的.o文件列表。<BR>
因此在一个目录下可以使用如下内容的Makefile来将工作目录下的所有的.c文件进行编译并最后连接成为一个可执行文件：
</DD>
<DT>atomic</DT>
<!--property:date_created=1538118894-->
<!--property:date_modified=1538118907-->
<DD>
__sync_fetch_and_add系列的命令，发现这个系列命令讲的最好的一篇文章，英文好的同学可以直接去看原文。Multithreaded simple data type access and atomic variables<BR>
__sync_fetch_and_add系列一共有十二个函数，有加/减/与/或/异或/等函数的原子性操作函数,__sync_fetch_and_add,顾名思义，先fetch，然后自加，返回的是自加以前的值。以count = 4为例，调用__sync_fetch_and_add(&amp;count,1),之后，返回值是4，然后，count变成了5.<BR>
有__sync_fetch_and_add,自然也就有__sync_add_and_fetch，呵呵这个的意思就很清楚了，先自加，在返回。他们哥俩的关系与i++和++i的关系是一样的。被谭浩强他老人家收过保护费的都会清楚了。<BR>
有了这个宝贝函数，我们就有新的解决办法了。对于多线程对全局变量进行自加，我们就再也不用理线程锁了。下面这行代码，和上面被pthread_mutex保护的那行代码作用是一样的，而且也是线程安全的。<BR>
__sync_fetch_and_add( &amp;global_int, 1 );<BR>
下面是这群函数的全家福，大家看名字就知道是这些函数是干啥的了。<BR>
在用gcc编译的时候要加上选项 -march=i686<BR>
// sam:在我的服务器上，发现不加都可以。<BR>
<BR>
type __sync_fetch_and_add (type *ptr, type value);<BR>
type __sync_fetch_and_sub (type *ptr, type value);<BR>
type __sync_fetch_and_or (type *ptr, type value);<BR>
type __sync_fetch_and_and (type *ptr, type value);<BR>
type __sync_fetch_and_xor (type *ptr, type value);<BR>
type __sync_fetch_and_nand (type *ptr, type value);<BR>
type __sync_add_and_fetch (type *ptr, type value);<BR>
type __sync_sub_and_fetch (type *ptr, type value);<BR>
type __sync_or_and_fetch (type *ptr, type value);<BR>
type __sync_and_and_fetch (type *ptr, type value);<BR>
type __sync_xor_and_fetch (type *ptr, type value);<BR>
type __sync_nand_and_fetch (type *ptr, type value);<BR>
 <BR>
<BR>
---------------------<BR>
<BR>
本文来自 风吹过的时光 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/hzhsan/article/details/25124901?utm_source=copy 
</DD>
<DT>api</DT>
<!--property:date_created=1528078436-->
<!--property:date_modified=1528078436-->
<!--property:expanded-->
<DD>
<DL>
<DT>sched_setaffinity</DT>
<!--property:date_created=1528078447-->
<!--property:date_modified=1528078472-->
<DD>
SYNOPSIS<BR>
       #define _GNU_SOURCE             /* See feature_test_macros(7) */<BR>
       #include &lt;sched.h&gt;<BR>
<BR>
       int sched_setaffinity(pid_t pid, size_t cpusetsize,<BR>
                             const cpu_set_t *mask);<BR>
<BR>
       int sched_getaffinity(pid_t pid, size_t cpusetsize,<BR>
                             cpu_set_t *mask);<BR>
<BR>
DESCRIPTION<BR>
       A  thread's  CPU affinity mask determines the set of CPUs on which it is eligible to run.  On a multiprocessor system, setting the CPU affinity mask can be used to obtain perfor‐<BR>
       mance benefits.  For example, by dedicating one CPU to a particular thread (i.e., setting the affinity mask of that thread to specify a single CPU, and setting the affinity  mask<BR>
       of  all other threads to exclude that CPU), it is possible to ensure maximum execution speed for that thread.  Restricting a thread to run on a single CPU also avoids the perfor‐<BR>
       mance cost caused by the cache invalidation that occurs when a thread ceases to execute on one CPU and then recommences execution on a different CPU.<BR>
<BR>
       A CPU affinity mask is represented by the cpu_set_t structure, a &quot;CPU set&quot;, pointed to by mask.  A set of macros for manipulating CPU sets is described in CPU_SET(3).<BR>
<BR>
       sched_setaffinity() sets the CPU affinity mask of the thread whose ID is pid to the value specified by mask.  If pid is zero, then the  calling  thread  is  used.   The  argument<BR>
       cpusetsize is the length (in bytes) of the data pointed to by mask.  Normally this argument would be specified as sizeof(cpu_set_t).<BR>
<BR>
       If the thread specified by pid is not currently running on one of the CPUs specified in mask, then that thread is migrated to one of the CPUs specified in mask.<BR>
<BR>
       sched_getaffinity() writes the affinity mask of the thread whose ID is pid into the cpu_set_t structure pointed to by mask.  The cpusetsize argument specifies the size (in bytes)<BR>
       of mask.  If pid is zero, then the mask of the calling thread is returned.<BR>
<BR>
RETURN VALUE<BR>
       On success, sched_setaffinity() and sched_getaffinity() return 0.  On error, -1 is returned, and errno is set appropriately.<BR>

</DD>
<DT>pthread_detach</DT>
<!--property:date_created=1528083405-->
<!--property:date_modified=1528083432-->
<DD>
NAME<BR>
       pthread_detach - detach a thread<BR>
<BR>
SYNOPSIS<BR>
       #include &lt;pthread.h&gt;<BR>
<BR>
       int pthread_detach(pthread_t thread);<BR>
<BR>
       Compile and link with -pthread.<BR>
<BR>
DESCRIPTION<BR>
       The  pthread_detach()  function marks the thread identified by thread as detached.  When a detached thread terminates, its resources are automatically released back to the system<BR>
       without the need for another thread to join with the terminated thread.<BR>
<BR>
       Attempting to detach an already detached thread results in unspecified behavior.<BR>
<BR>
RETURN VALUE<BR>
       On success, pthread_detach() returns 0; on error, it returns an error number.<BR>

</DD>
<DT>backtrace</DT>
<!--property:date_created=1530263011-->
<!--property:date_modified=1530263062-->
<DD>
 SYNOPSIS<BR>
      #include &lt;execinfo.h&gt;<BR>
<BR>
       int backtrace(void **buffer, int size);<BR>
<BR>
       char **backtrace_symbols(void *const *buffer, int size);<BR>
<BR>
<BR>
DESCRIPTION<BR>
       backtrace()  returns  a backtrace for the calling program, in the array pointed to by buffer.  A backtrace is the series of currently active function calls for the program.  Each<BR>
       item in the array pointed to by buffer is of type void *, and is the return address from the corresponding stack frame.   The  size  argument  specifies  the  maximum  number  of<BR>
       addresses that can be stored in buffer.  If the backtrace is larger than size, then the addresses corresponding to the size most recent function calls are returned; to obtain the<BR>
       complete backtrace, make sure that buffer and size are large enough.<BR>
<BR>
       Given the set of addresses returned by backtrace() in buffer, backtrace_symbols() translates the addresses into an array of strings that describe the addresses symbolically.  The<BR>
       size  argument  specifies the number of addresses in buffer.  The symbolic representation of each address consists of the function name (if this can be determined), a hexadecimal<BR>
       offset into the function, and the actual return address (in hexadecimal).  The address of the array of string pointers is returned as the function result of  backtrace_symbols().<BR>
       This array is malloc(3)ed by backtrace_symbols(), and must be freed by the caller.  (The strings pointed to by the array of pointers need not and should not be freed.)<BR>
<BR>
NOTES<BR>
       These functions make some assumptions about how a function's return address is stored on the stack.  Note the following:<BR>
<BR>
       *  Omission of the frame pointers (as implied by any of gcc(1)'s nonzero optimization levels) may cause these assumptions to be violated.<BR>
<BR>
       *  Inlined functions do not have stack frames.<BR>
<BR>
       *  Tail-call optimization causes one stack frame to replace another.<BR>
<BR>
       The  symbol  names may be unavailable without the use of special linker options.  For systems using the GNU linker, it is necessary to use the -rdynamic linker option.  Note that<BR>
       names of &quot;static&quot; functions are not exposed, and won't be available in the backtrace.<BR>

</DD>
<DT>PRId64</DT>
<!--property:date_created=1532054494-->
<!--property:date_modified=1532054501-->
<DD>
c++使用PRID64，需要两步：<BR>
<BR>
包含头文件：&lt;inttypes.h&gt;<BR>
定义宏：__STDC_FORMAT_MACROS，可以通过编译时加-D__STDC_FORMAT_MACROS，或者在包含文件之前定义这个宏。
</DD>
<DT>crypto</DT>
<!--property:date_created=1534321694-->
<!--property:date_modified=1534321708-->
<DD>
node:<BR>
/proc/crypto
</DD>
</DL>

</DD>
<DT>kernel</DT>
<!--property:date_created=1524187843-->
<!--property:date_modified=1524187843-->
<!--property:expanded-->
<DD>
<DL>
<DT>make</DT>
<!--property:date_created=1526956713-->
<!--property:date_modified=1526957464-->
<DD>
make V=1   开启makefile的打印<BR>
<BR>
Use make M=dir to specify directory of external module to build<BR>
<BR>
Use make W=1 to enable warnings (see scripts/Makefile.build)<BR>
<BR>
# INSTALL_MOD_STRIP, if defined, will cause modules to be<BR>
# stripped after they are installed.  If INSTALL_MOD_STRIP is '1', then<BR>
# the default option --strip-debug will be used.  Otherwise,<BR>
# INSTALL_MOD_STRIP value will be used as the options to the strip command.
</DD>
<DT>LINUX_VERSION_CODE</DT>
<!--property:date_created=1532315287-->
<!--property:date_modified=1532315314-->
<DD>
include/generated/uapi/linux/version.h<BR>
<BR>
#define KERNEL_VERSION(a,b,c) (((a) &lt;&lt; 16) + ((b) &lt;&lt; 8) + (c))
</DD>
<DT>gpio emulate i2c</DT>
<!--property:date_created=1533093401-->
<!--property:date_modified=1533093437-->
<DD>
/********************************************************************/<BR>
#define set_gpio_direction(gpio, out) gpio_tlmm_config(gpio, 0, out, GPIO_NO_PULL, GPIO_8MA, GPIO_ENABLE);<BR>
#define get_gpio_value gpio_status<BR>
static void Delay()<BR>
{<BR>
    int i;<BR>
<BR>
    for(i = 0;i &lt; 50;i++)<BR>
        dsb();<BR>
}<BR>
#define SDA 6 <BR>
#define SCL 7 <BR>
<BR>
static inline void SET_VALUE(int gpio, int val) <BR>
{<BR>
    gpio_tlmm_config(gpio, 0, 1, GPIO_NO_PULL, GPIO_8MA, GPIO_ENABLE);<BR>
    gpio_set_val(gpio, val);<BR>
}<BR>
<BR>
#define GPIO_INPUT_VAL(gpio) gpio_status(gpio)<BR>
#define GPIO_DIRECTION_INPUT(gpio) gpio_tlmm_config(gpio, 0, 0, GPIO_NO_PULL, GPIO_8MA, GPIO_ENABLE)<BR>
<BR>
#define SET_HIGH(gpio) SET_VALUE(gpio, 1)<BR>
#define SET_LOW(gpio) SET_VALUE(gpio, 0)<BR>
<BR>
void I2C_Start(void)<BR>
{<BR>
    SET_HIGH(SCL);<BR>
    SET_HIGH(SDA);<BR>
    Delay();<BR>
    SET_LOW(SDA);<BR>
    Delay();<BR>
    SET_LOW(SCL);<BR>
}<BR>
<BR>
uint8_t I2C_RecvACK()<BR>
{<BR>
    uint8_t CY;<BR>
    SET_HIGH(SCL);<BR>
    GPIO_DIRECTION_INPUT(SDA); <BR>
    Delay();               <BR>
    if(GPIO_INPUT_VAL(SDA))         <BR>
    {<BR>
        CY=1;<BR>
    }<BR>
    else CY=0;<BR>
    SET_LOW(SCL);      <BR>
    Delay();                <BR>
    return CY;<BR>
}<BR>
<BR>
void I2C_SendACK(uint8_t ack)<BR>
{<BR>
    if (ack==1)<BR>
    {<BR>
        SET_HIGH(SDA);<BR>
    }<BR>
    else<BR>
    {<BR>
        SET_LOW(SDA);<BR>
    }<BR>
    SET_HIGH(SCL);<BR>
    Delay();<BR>
    SET_LOW(SCL);  <BR>
    Delay(); <BR>
}<BR>
<BR>
void I2C_SendByte(uint8_t dat)<BR>
{<BR>
    uint8_t i;<BR>
    for (i=0; i&lt;8; i++)<BR>
    {                  <BR>
        if (dat&amp;0x80)<BR>
        {<BR>
            SET_HIGH(SDA);<BR>
        }<BR>
        else<BR>
        {<BR>
            SET_LOW(SDA);<BR>
        }<BR>
        dat &lt;&lt;= 1;<BR>
        SET_HIGH(SCL);<BR>
        Delay(); <BR>
        SET_LOW(SCL);<BR>
        Delay(); <BR>
    }<BR>
    I2C_RecvACK();<BR>
}<BR>
<BR>
uint8_t I2C_RecvByte()<BR>
{<BR>
    uint8_t i;<BR>
    uint8_t dat = 0;<BR>
    SET_HIGH(SDA);<BR>
    <BR>
    GPIO_DIRECTION_INPUT(SDA); <BR>
    for (i=0; i&lt;8; i++)<BR>
    {<BR>
        dat &lt;&lt;= 1;<BR>
        SET_HIGH(SCL);<BR>
        Delay();<BR>
        if(GPIO_INPUT_VAL(SDA))         <BR>
        {<BR>
            dat|=0x01;<BR>
        }<BR>
        else dat|=0;          <BR>
        SET_LOW(SCL);<BR>
        Delay();<BR>
    }<BR>
    return dat;<BR>
}<BR>
<BR>
void I2C_Stop()<BR>
{<BR>
    SET_LOW(SDA);<BR>
    SET_HIGH(SCL);<BR>
    Delay();;<BR>
    SET_HIGH(SDA);<BR>
    Delay();<BR>
}<BR>
<BR>
#define SlaveAddress (0xd6)<BR>
void Single_WriteI2C(uint8_t REG_Address,uint8_t REG_data)<BR>
{<BR>
    I2C_Start(); <BR>
    I2C_SendByte(SlaveAddress);<BR>
    I2C_SendByte(REG_Address);<BR>
    I2C_SendByte(REG_data);<BR>
    I2C_Stop();<BR>
}<BR>
<BR>
uint8_t Single_ReadI2C(uint8_t REG_Address)<BR>
{<BR>
    uint8_t REG_data;<BR>
    I2C_Start();<BR>
    I2C_SendByte(SlaveAddress);<BR>
    I2C_SendByte(REG_Address);<BR>
    I2C_Start();<BR>
    I2C_SendByte(SlaveAddress|0x01); <BR>
    REG_data=I2C_RecvByte(); <BR>
    I2C_SendACK(1); <BR>
    I2C_Stop(); <BR>
    return REG_data;<BR>
}<BR>
<BR>
static int restore_i2c(void)<BR>
{<BR>
    int n = 0;<BR>
<BR>
    while(n++ &lt; 9)<BR>
    {<BR>
        SET_LOW(SCL);<BR>
        Delay();<BR>
<BR>
        if(GPIO_INPUT_VAL(SDA) != 0)<BR>
            break;<BR>
<BR>
        SET_HIGH(SCL);<BR>
        Delay();<BR>
    }<BR>
<BR>
    if(GPIO_INPUT_VAL(SDA) == 0)<BR>
        return -1;<BR>
<BR>
    SET_LOW(SDA);<BR>
    Delay();<BR>
    SET_HIGH(SCL);<BR>
    Delay();<BR>
    SET_HIGH(SDA);<BR>
    Delay();<BR>
<BR>
    return 0;<BR>
}<BR>
<BR>
void test_i2c()<BR>
{<BR>
    uint8_t reg;<BR>
    int addr = 0;<BR>
<BR>
    GPIO_DIRECTION_INPUT(SDA); <BR>
    if(GPIO_INPUT_VAL(SDA) == 0)<BR>
    {<BR>
        printf(&quot;%s detected a bad loop i2c device\n&quot;, __func__);<BR>
        if(restore_i2c() &lt; 0)<BR>
        {<BR>
            printf(&quot;%s restore i2c device failed!\n&quot;, __func__);<BR>
            return;<BR>
        }<BR>
    }<BR>
<BR>
    reg =  Single_ReadI2C(addr);<BR>
    printf(&quot;reg: %x\r\n&quot;, reg);<BR>
<BR>
    Single_WriteI2C(0x00, 0x17);<BR>
<BR>
    for(addr = 0;addr &lt; 0x0a;addr++)<BR>
    {<BR>
        reg =   Single_ReadI2C(addr);<BR>
        printf(&quot;reg(0x%x): %x\r\n&quot;, addr, reg);<BR>
    }<BR>
}<BR>

</DD>
</DL>

</DD>
<DT>tracing</DT>
<!--property:date_created=1524187852-->
<!--property:date_modified=1524187852-->
<!--property:expanded-->
<DD>
<DL>
<DT>bpf</DT>
<!--property:date_created=1524187860-->
<!--property:date_modified=1524187888-->
<DD>
https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/index.html
</DD>
</DL>

</DD>
</DL>

</DD>
<DT>project</DT>
<!--property:date_created=1528096447-->
<!--property:date_modified=1529409081-->
<!--property:expanded-->
<DD>
<DL>
<DT>go</DT>
<!--property:date_created=1525693500-->
<!--property:date_modified=1530094586-->
<!--property:expanded-->
<DD>
<BR>
svn://192.168.2.12/2018/project/bipc_4g<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
TEST00000BBW0OTL<DL>
<DT>tftp</DT>
<!--property:date_created=1525693506-->
<!--property:date_modified=1526455527-->
<DD>
tftp 0x2000000 dvr.bin;sf probe 0;sf erase 0x100000 0x300000;sf write 0x2000000 0x110000 0x2F0000<BR>
tftp 0x2000000 dvr.bin;sf probe 0;sf erase 0x100000 0x400000;sf write 0x2000000 0x110000 0x3f0000<BR>
<BR>
tftp 0 dvr.bin;go 0<BR>
<BR>
烧录resource：tftp 0x2000000 resource;sf probe 0;sf erase 0x380000 0x80000;sf write 0x2000000 0x380000 0x80000<BR>
tftp 0x2000000 resource;sf probe 0;sf erase 0x500000 0x80000;sf write 0x2000000 0x500000 0x80000<BR>
<BR>
烧录boot：<BR>
tftp 0x2000000 uboot_rtos_4g_2s_nb.bin;sf probe 0;sf erase 0x0 0x60000;sf write 0x2000000 0x00000 0x60000
</DD>
<DT>flashcp</DT>
<!--property:date_created=1528185031-->
<!--property:date_modified=1529393173-->
<DD>
flashcp /tmp/app.squashfs.img /dev/mtd4<BR>
<BR>
<BR>
mount -t nfs -o nolock 192.168.2.11:/home/mjk/share /mnt/nfs
</DD>
<DT>netserver</DT>
<!--property:date_created=1525745883-->
<!--property:date_modified=1528426040-->
<!--property:expanded-->
<DD>
port：9000
</DD>
<DT>compile</DT>
<!--property:date_created=1525745890-->
<!--property:date_modified=1530760931-->
<DD>
rtos:<BR>
make _PLATFORM_=GM8136S_FREERTOS _TYPE_=IPC _BIPC_TYPE_=4G static release<BR>
<BR>
linux:<BR>
make _PLATFORM_=GM8135S4G _TYPE_=IPC static release
</DD>
<DT>makejson</DT>
<!--property:date_created=1537523945-->
<!--property:date_modified=1537523953-->
<DD>
<BR>
./tools/makejson.sh STM835S8MD_GOv1.82.154.00_18092100.2MP.D2.REOLINK.RF/STM835S8MD_GOv1.82.154.00_18092100.2MP.D2.REOLINK.RF.pak<BR>

</DD>
<DT>manufacture</DT>
<!--property:date_created=1526611107-->
<!--property:date_modified=1526874930-->
<DD>
TEST00000BAFR123
</DD>
<DT>wifi</DT>
<!--property:date_created=1534410755-->
<!--property:date_modified=1534410768-->
<DD>
drivers: AR6000<BR>
drivers/net/wireless/ath/ath6kl/
</DD>
<DT>track</DT>
<!--property:date_created=1541995339-->
<!--property:date_modified=1542006129-->
<DD>
aws s3 cp s3://reolink-storage/develop/devices/uids/2018-11-11.json.gz device_type_lib.json.gz<BR>
<BR>
aws s3 cp s3://reolink-storage/develop/logs/p2p/cmds/2018-11-11.json.gz ./<BR>
<BR>
aws s3 cp s3://reolink-storage/develop/logs/p2p/conn/2018-11-11.sql.gz ./
</DD>
</DL>

</DD>
<DT>gopro</DT>
<!--property:date_created=1531964145-->
<!--property:date_modified=1531964145-->
<!--property:expanded-->
<DD>
<DL>
<DT>compile</DT>
<!--property:date_created=1525745890-->
<!--property:date_modified=1531964176-->
<DD>
rtos:<BR>
make _PLATFORM_=GM8136S_FREERTOS _TYPE_=IPC _BIPC_TYPE_=4G static release<BR>
<BR>
linux:<BR>
make _PLATFORM_=Q9X07 _TYPE_=IPC static release
</DD>
<DT>usb net</DT>
<!--property:date_created=1534765811-->
<!--property:date_modified=1534765823-->
<DD>
echo rndis &gt; /sbin/usb/compositions/usb_net_type
</DD>
</DL>

</DD>
</DL>

</DD>
<DT>vendor</DT>
<!--property:date_created=1528096463-->
<!--property:date_modified=1528096463-->
<!--property:expanded-->
<DD>
<DL>
<DT>quectel</DT>
<!--property:date_created=1524187968-->
<!--property:date_modified=1526870365-->
<!--property:expanded-->
<DD>
<BR>
移远通信专注于高品质无线通信模组产品的设计、研发和制造。公司是无线通信模组业界的先导者，拥有经验丰富的管理和研发团队，以不断的创新、出众的品质和令人信赖的可靠性得到广泛认可，产品广泛应用于汽车、智能计量、远程控制、物体跟踪、无线支付、安全监控、健康护理等领域。<BR>
<BR>
 <BR>
<BR>
移远通信凭借一流的技术，已开发有完整的高性能GSM/GPRS、WCDMA/HSPA(+)、LTE、GNSS模组产品系列，多样性的产品及功能充分满足了不同市场的需求。移远通信始终保证所有产品的质量完全满足客户的要求。超小尺寸、超低功耗、易于集成、长期使用性及超高的稳定性是移远通信模组产品的核心特点。<BR>
<BR>
 <BR>
<BR>
移远通信拥有上海和合肥两个研发中心、全球超过30个办事处，保证技术支持和研发团队紧密配合全球代理商，为客户提供全面、及时和近距离的技术支持服务，缩短客户产品研发时间，帮助客户产品早日成熟上市。<BR>
<BR>
 <BR>
<BR>
移远通信秉持“确保客户竞争力” 的信念，不断研发通信模组核心技术，完善、创新自身产品，丰富产品系列，保证客户投资移远通信产品的不断升值。<DL>
<DT>ec21</DT>
<!--property:date_created=1524187973-->
<!--property:date_modified=1532058061-->
<!--property:expanded-->
<DD>
pm:pm8019    dts:msm-pm8019.dtsi<DL>
<DT>reboot</DT>
<!--property:date_created=1527155896-->
<!--property:date_modified=1527157627-->
<DD>
通过函数check_reboot_mode判断aboot启动模式（fastboot或recovery等）<BR>
<BR>
kernel:drivers/power/reset/msm-poweroff.c
</DD>
<DT>powerkey</DT>
<!--property:date_created=1531462273-->
<!--property:date_modified=1531462300-->
<DD>
qcom,qpnp-power-on<BR>
driver:<BR>
drivers/platform/msm/qpnp-power-on.c
</DD>
<DT>adc</DT>
<!--property:date_created=1531475335-->
<!--property:date_modified=1532057786-->
<DD>
dts: qcom,qpnp-vadc<BR>
driver:drivers/hwmon/qpnp-adc-voltage.c<BR>
<BR>
sys节点：<BR>
/sys/devices/qpnp-vadc-8/vbat_sns<BR>
/sys/devices/qpnp-vadc-8/mpp6_vadc
</DD>
<DT>quectel wake lock</DT>
<!--property:date_created=1534210974-->
<!--property:date_modified=1534210997-->
<DD>
driver:<BR>
drivers/base/power/quec_wakelock.c<BR>
node:<BR>
/proc/quec_wakelock
</DD>
</DL>

</DD>
</DL>

</DD>
</DL>

</DD>
<DT>rtos</DT>
<!--property:date_created=1528096491-->
<!--property:date_modified=1528096491-->
<DD>
<DL>
<DT>FreeRTOS</DT>
<!--property:date_created=1526625889-->
<!--property:date_modified=1526625889-->
<!--property:expanded-->
<DD>
<DL>
<DT>thread</DT>
<!--property:date_created=1526625895-->
<!--property:date_modified=1526626590-->
<DD>
BaseType_t xTaskCreate(  <BR>
         TaskFunction_t pvTaskCode,  <BR>
         const charchar * const pcName,  <BR>
         unsigned short usStackDepth,  <BR>
         voidvoid *pvParameters,  <BR>
         UBaseType_t uxPriority,  <BR>
         TaskHandle_t * pvCreatedTask  <BR>
       );  <BR>
<BR>
pvTaskCode：指针，指向任务函数的入口。任务永远不会返回（位于死循环内）。该参数类型TaskFunction_t定义在文件projdefs.h中，定义为：typedefvoid (*TaskFunction_t)( void * )。<BR>
pcName：任务描述。主要用于调试。字符串的最大长度由宏configMAX_TASK_NAME_LEN指定，该宏位于FreeRTOSConfig.h文件中。<BR>
usStackDepth：指定任务堆栈大小，能够支持的堆栈变量数量，而不是字节数。比如，在16位宽度的堆栈下，usStackDepth定义为100，则实际使用200字节堆栈存储空间。堆栈的宽度乘以深度必须不超过size_t类型所能表示的最大值。比如，size_t为16位，则可以表示的最大值是65535。<BR>
pvParameters：指针，当任务创建时，作为一个参数传递给任务。<BR>
uxPriority：任务的优先级。具有MPU支持的系统，可以通过置位优先级参数的portPRIVILEGE_BIT位，随意的在特权（系统）模式下创建任务。比如，创建一个优先级为2的特权任务，参数uxPriority可以设置为( 2 | portPRIVILEGE_BIT )。<BR>
pvCreatedTask：用于回传一个句柄（ID），创建任务后可以使用这个句柄引用任务。<BR>
<BR>
 如果任务成功创建并加入就绪列表函数返回pdPASS，否则函数返回错误码，具体参见projdefs.h。<BR>
----------------------------------------------------------------------------------------------------------------------------------<BR>
voidvTaskDelete( TaskHandle_t xTask );<BR>
<BR>
xTask：被删除任务的句柄。为NULL表示删除当前任务。<BR>
----------------------------------------------------------------------------------------------------------------------------------<BR>
<BR>
 void vTaskPrioritySet( TaskHandle_txTask,<BR>
<BR>
                       UBaseType_tuxNewPriority );<BR>
 设置指定任务的优先级。如果设置的优先级高于当前运行的任务，在函数返回前会进行一次上下文切换。在文件FreeRTOSConfig.h中，宏INCLUDE_vTaskPrioritySet 必须设置成1，此函数才有效。<BR>
<BR>
xTask：要设置优先级任务的句柄，为NULL表示设置当前运行的任务。<BR>
uxNewPriority：要设置的新优先级。<BR>
----------------------------------------------------------------------------------------------------------------------------------<BR>
<BR>
void vTaskSuspend( TaskHandle_txTaskToSuspend );<BR>
BaseType_t xTaskResumeFromISR(TaskHandle_t xTaskToResume );<BR>
      挂起指定任务。被挂起的任务绝不会得到处理器时间，不管该任务具有什么优先级。<BR>
<BR>
      调用vTaskSuspend函数是不会累计的：即使多次调用vTaskSuspend ()函数将一个任务挂起，也只需调用一次vTaskResume ()函数就能使挂起的任务解除挂起状态。在文件FreeRTOSConfig.h中，宏INCLUDE_vTaskSuspend必须设置成1，此函数才有效。<BR>
<BR>
xTaskToSuspend：要挂起的任务句柄。为NULL表示挂起当前任务。<BR>
----------------------------------------------------------------------------------------------------------------------------------<BR>
<BR>
void vTaskResume( TaskHandle_txTaskToResume );<BR>
<BR>
      恢复挂起的任务。<BR>
<BR>
      通过调用一次或多次vTaskSuspend()挂起的任务，可以调用一次vTaskResume ()函数来再次恢复运行。在文件FreeRTOSConfig.h中，宏INCLUDE_vTaskSuspend必须置1，此函数才有效。<BR>
<BR>
xTaskToResume：要恢复运行的任务句柄。<BR>
----------------------------------------------------------------------------------------------------------------------------------<BR>
<BR>
TaskHandle_t xTaskGetCurrentTaskHandle(void );<BR>
<BR>
      在文件FreeRTOSConfig.h中，宏INCLUDE_xTaskGetCurrentTaskHandle必须设置为1，此函数才有效。<BR>
----------------------------------------------------------------------------------------------------------------------------------<BR>
<BR>
BaseType_t xTaskNotify( TaskHandle_txTaskToNotify,  <BR>
                uint32_t ulValue,  <BR>
                eNotifyAction eAction);  <BR>
向指定任务发送指定的通知值。如果打算使用RTOS任务通知实现轻量级的二进制或计数信号量，推荐使用API函数xTaskNotifyGive()来代替本函数。<BR>
<BR>
      此函数不可以在中断服务例程中调用，中断保护等价函数为xTaskNotifyFromISR()。<BR>
xTaskToNotify：被通知的任务句柄。<BR>
ulValue：通知更新值<BR>
eAction：枚举类型，指明更新通知值的方法<BR>
----------------------------------------------------------------------------------------------------------------------------------<BR>
<BR>
BaseType_t xTaskNotifyGive(TaskHandle_t xTaskToNotify );<BR>
<BR>
      其实这是一个宏，本质上相当于xTaskNotify( ( xTaskToNotify ), ( 0 ), eIncrement )。可以使用该API函数代替二进制或计数信号量，但速度更快。在这种情况下，应该使用API函数ulTaskNotifyTake()来等待通知，而不应该使用API函数xTaskNotifyWait()。<BR>
<BR>
      此函数不可以在中断服务例程中调用，中断保护等价函数为vTaskNotifyGiveFromISR()。<BR>
<BR>
xTaskToNotify：被通知的任务句柄。<BR>
----------------------------------------------------------------------------------------------------------------------------------
</DD>
<DT>semaphore</DT>
<!--property:date_created=1526626327-->
<!--property:date_modified=1528426081-->
<DD>
SemaphoreHandle_t  xSemaphoreCreateBinary( void );<BR>
<BR>
这个函数用于创建一个二进制信号量。二进制信号量要么有效要么无效，这也是为什么叫做二进制的原因。<BR>
<BR>
       新创建的信号量处于无效状态，这意味着使用API函数xSemaphoreTake()获取信号之前，需要先给出信号。<BR>
<BR>
       二进制信号量和互斥量非常相似，但也有细微的区别：互斥量具有优先级继承机制，二进制信号量没有这个机制。这使得二进制信号量更适合用于同步（任务之间或者任务和中断之间），互斥量更适合互锁。<BR>
<BR>
       一旦获得二进制信号量后不需要恢复，一个任务或中断不断的产生信号，而另一个任务不断的取走这个信号，通过这样的方式来实现同步。<BR>
<BR>
       低优先级任务拥有互斥量的时候，如果另一个高优先级任务也企图获取这个信号量，则低优先级任务的优先级会被临时提高，提高到和高优先级任务相同的优先级。这意味着互斥量必须要释放，否则高优先级任务将不能获取这个互斥量，<BR>
       并且那个拥有互斥量的低优先级任务也永远不会被剥夺，这就是操作系统中的优先级翻转。<BR>
<BR>
       互斥量和二进制信号量都是SemaphoreHandle_t类型，并且可以用于任何具有这类参数的API函数中。<BR>
<BR>
 NULL：创建信号量失败，因为FreeRTOS堆栈不足。<BR>
 其它值：信号量创建成功。这个返回值存储着信号量句柄。<BR>
----------------------------------------------------------------------------------------------------------------------------------<BR>
<BR>
SemaphoreHandle_t xSemaphoreCreateCounting ( UBaseType_t uxMaxCount,  <BR>
                                 UBaseType_t uxInitialCount )  <BR>
<BR>
 uxMaxCount：最大计数值，当信号到达这个值后，就不再增长了。<BR>
 uxInitialCount：创建信号量时的初始值。<BR>
----------------------------------------------------------------------------------------------------------------------------------<BR>
<BR>
 SemaphoreHandle_t xSemaphoreCreateMutex( void )<BR>
----------------------------------------------------------------------------------------------------------------------------------<BR>
<BR>
SemaphoreTake(SemaphoreHandle_t xSemaphore, TickType_t xTicksToWait)<BR>
xSemaphoreTakeFromISR(SemaphoreHandle_t xSemaphore,  <BR>
                signedBaseType_t *pxHigherPriorityTaskWoken)  <BR>
       获取信号量。信号量必须是通过API函数xSemaphoreCreateBinary()、xSemaphoreCreateCounting()和xSemaphoreCreateMutex()预先创建过的。注意，递归互斥量类型信号量不能使用该函数、不用在中断服务程序中使用该函数。<BR>
<BR>
 xSemaphore：信号量句柄<BR>
 xTickToWait：信号量无效时，任务最多等待的时间，单位是系统节拍周期个数。使用宏portTICK_PERIOD_MS可以辅助将系统节拍个数转化为实际时间（以毫秒为单位）。如果设置为0，表示不是设置等待时间。如果INCLUDE_vTaskSuspend设置为1，并且参数xTickToWait为portMAX_DELAY则可以无限等待。<BR>
 成功获取到信号量返回pdTRUE，否则返回pdFALSE。<BR>
---------------------------------------------------------------------------------------------------------------------------------- <BR>
xSemaphoreGive(SemaphoreHandle_t xSemaphore )<BR>
xSemaphoreGiveFromISR(SemaphoreHandle_t xSemaphore,  <BR>
                         signed BaseType_t *pxHigherPriorityTaskWoken )  <BR>
<BR>
       用于释放一个信号量。信号量必须是API函数xSemaphoreCreateBinary()、xSemaphoreCreateCounting()或xSemaphoreCreateMutex() 创建的。必须使用API函数xSemaphoreTake()获取这个信号量。<BR>
<BR>
       这个函数绝不可以在中断服务例程中使用，可以使用带中断保护版本的API函数xSemaphoreGiveFromISR()来实现相同功能。<BR>
<BR>
       这个函数不能用于使用API函数xSemaphoreCreateRecursiveMutex()所创建的递归互斥量。<BR>
<BR>
 xSemaphore：信号量句柄。<BR>
pxHigherPriorityTaskWoken：如果*pxHigherPriorityTaskWoken为pdTRUE，则需要在中断退出前人为的经行一次上下文切换。从FreeRTOS V7.3.0开始，该参数为可选参数，并可以设置为NULL。<BR>
<BR>
信号量释放成功返回pdTRUE，否则返回pdFALSE。<BR>
---------------------------------------------------------------------------------------------------------------------------------- 
</DD>
</DL>

</DD>
<DT>newlib</DT>
<!--property:date_created=1526547944-->
<!--property:date_modified=1526869320-->
<DD>
newlib是一个面向嵌入式系统的c库，目前由Red Hat维护。相对常用于linux的c库glibc，其实现了大部分的功能函数，但体积却小很多。<BR>
尤其是newlib独特的体系结构，具体实现与操作系统分层，使之能够很好地进行配置，满足深度嵌入式系统的要求。<BR>
由于专为嵌入式系统设计，newlib具有可移植性强、轻量级、速度快、功能完备等特点，已广泛应用于各种嵌入式系统中。<BR>
<BR>
git://sourceware.org/git/newlib-cygwin.git<BR>
<BR>
./configure --prefix=/home/mjk/usr/arm/usr/ --host=arm-none-eabi --with-newlib
</DD>
</DL>

</DD>
<DT>av</DT>
<!--property:date_created=1528096504-->
<!--property:date_modified=1528096504-->
<!--property:expanded-->
<DD>
<DL>
<DT>rtsp</DT>
<!--property:date_created=1527062944-->
<!--property:date_modified=1527063324-->
<DD>
sprop-parameter-sets=Z0IACpZTBYmI, aMljiA==<BR>
<BR>
sprop-parameter-sets（此选项为h264/h265独有）后面跟的是sps和pps帧的base64码，用逗号分隔。<BR>
==========================================================================
</DD>
<DT>ffmpeg</DT>
<!--property:date_created=1528702248-->
<!--property:date_modified=1528885728-->
<!--property:expanded-->
<DD>
<DL>
<DT>ffplay</DT>
<!--property:date_created=1528702257-->
<!--property:date_modified=1528702263-->
<DD>
ffplay -nodisp
</DD>
<DT>filter</DT>
<!--property:date_created=1528885730-->
<!--property:date_modified=1528949846-->
<DD>
bs2b<BR>
crossfeed<BR>
earwax<BR>
extrastereo<BR>
headphone<BR>
sofalizer<BR>
surround<BR>
<BR>
<BR>
<BR>
<BR>
firequalizer<BR>
equalizer<BR>
superequalizer<BR>
treble
</DD>
</DL>

</DD>
</DL>

</DD>
</DL>
</BODY>
</HTML>
